
<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>いい感じにチーム分けしてくれるやつ</title>
  <style>
    body {
      font-family: "Hiragino Maru Gothic ProN", sans-serif;
      background: #f7fcfc;
      margin: 0;
      padding-top: 100px;
    }

    header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background-color: #97EADB;
      padding: 1rem;
      text-align: center;
      z-index: 1000;
    }

    header h1 {
      margin: 0;
      font-size: 2rem;
      color: #fff;
    }

    /* ハンバーガーアイコン */
    .hamburger {
      font-size: 2rem;
      cursor: pointer;
      position: absolute;
      top: 50%;
      right: 3rem;
      color: white;
      transform: translateY(-50%);
      z-index: 1100;
    }

    nav {
      position: fixed;
      top: -100%;
      left: 0;
      width: 100%;
      background-color: #97EADB;
      display: flex;
      flex-direction: column;
      padding: 0;
      transition: top 0.3s ease;
      /* スライドアニメーション */
      z-index: 1050;
      /* ハンバーガーより下 */
    }

    nav.show {
      top: 80px;
      /* ヘッダーの下までスライド */
    }

    nav a {
      display: block;
      text-align: center;
      margin: 0;
      padding: 0.6rem 0;
      /* 左右は0に */
      font-size: 1.2rem;
      font-weight: bold;
      color: white;
      background-color: #97eadb;
      border-bottom: 1px solid #97EADB;
      text-decoration: none;
      transition: background-color 0.2s, transform 0.2s;
    }

    nav a:hover {
      background-color: #0099aa;
      transform: scale(1.03);
    }

    footer {
      background: #97EADB;
      text-align: center;
      color: white;
      padding: 1rem;
      margin-top: 2rem;
    }


    h1 {
      text-align: center;
      color: #47b6a2;
      margin-bottom: 12px;
    }

    .method-select {
      text-align: center;
      margin: 18px 0 12px 0;
      white-space: nowrap;
    }

    label {
      margin: 0 8px;
      font-weight: bold;
      color: #47b6a2;
      cursor: pointer;
      user-select: none;
      background: #fff;
      padding: 5px 10px;
      border-radius: 16px;
      border: 1.5px solid #97eadb;
      font-size: 14px;
    }

    .teams {
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin-bottom: 16px;
      align-items: center;
      /* 中央寄せ */
    }

    .team-box {
      width: 90%;
      /* 横幅を画面の90%に制限 */
      max-width: 500px;
      /* 最大幅を制限 */
      background: #eefaff;
      padding: 12px;
      border-radius: 12px;
      border: 2px solid #97eadb;
      text-align: center;
    }

    .team-box.team2 {
      background: #fff1f5;
      border-color: #ffb6c1;
    }

    .team-box h2 {
      font-size: 18px;
      margin: 0 0 8px 0;
      color: #47b6a2;
    }

    .team-box ul {
      list-style: none;
      padding: 0 8px;
      margin: 0;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      box-sizing: border-box;
    }

    .team-box li {
      background: white;
      border: 1.5px solid #ddd;
      border-radius: 8px;
      padding: 6px;
      font-size: 15px;
      font-weight: 500;
      text-align: center;
    }

    .player-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }

    .player {
      background: #fff;
      border: 2px solid #97eadb;
      border-radius: 10px;
      padding: 10px 6px;
      text-align: center;
      cursor: pointer;
      transition: transform 0.15s, box-shadow 0.15s;
      position: relative;
      font-size: 14px;
    }

    .player:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .player.selected {
      background: #97eadb;
      color: white;
    }

    .player.matching {
      background: #e0f7f3;
      border-color: #97eadb;
    }

    .pin-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 20px;
      height: 20px;
      background: none;
      border: none;
      cursor: pointer;
      padding: 0;
    }

    .pin-btn::before {
      content: "";
      position: absolute;
      inset: 0;
      background: #bbb;
      clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%,
          79% 91%, 50% 70%, 21% 91%, 32% 57%,
          2% 35%, 39% 35%);
      transition: background 0.3s;
    }

    .pin-btn.pinned::before {
      background: gold;
    }

    #matchCount {
      text-align: center;
      font-size: 12px;
      color: gray;
      margin-top: 8px;
      user-select: none;
    }

    .recent-toggle {
      text-align: center;
      margin-bottom: 10px;
    }

    /* ここからペア設定フォームのCSS */
    .pair-section {
      background: #eaf9f8;
      border: 2px solid #97eadb;
      border-radius: 12px;
      padding: 12px 16px;
      margin-bottom: 20px;
      /* max-width: 480px; */
      margin-left: auto;
      margin-right: auto;
    }

    .pair-section h3 {
      margin-top: 0;
      color: #47b6a2;
      font-weight: 700;
      font-size: 20px;
      margin-bottom: 10px;
      text-align: center;
    }

    .pair-form {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .pair-form input[type="text"] {
      flex: 1 1 40%;
      min-width: 100px;
      padding: 6px 8px;
      border: 1.5px solid #97eadb;
      border-radius: 8px;
      font-size: 14px;
    }

    .pair-form button {
      background: #47b6a2;
      border: none;
      color: white;
      padding: 6px 16px;
      border-radius: 16px;
      font-weight: 700;
      cursor: pointer;
      transition: background 0.3s;
    }

    .pair-form button:hover {
      background: #369482;
    }

    .pair-list {
      list-style: none;
      padding-left: 0;
      max-height: 150px;
      overflow-y: auto;
      margin: 0;
      border-top: 1px solid #97eadb;
    }

    .pair-list li {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid #b2e2dd;
      font-size: 14px;
      color: #333;
    }

    .pair-list button.delete-btn {
      background: #ff6b6b;
      border: none;
      color: white;
      border-radius: 12px;
      padding: 2px 8px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.3s;
    }

    .pair-list button.delete-btn:hover {
      background: #e03e3e;
    }

    @media (max-width: 600px) {
      h1 {
        font-size: 22px;
      }

      .team-box h2 {
        font-size: 16px;
      }

      .team-box li {
        font-size: 14px;
        padding: 5px;
      }

      .player-list {
        grid-template-columns: repeat(2, 1fr);
      }

      .pair-form {
        flex-direction: column;
        align-items: center;
      }

      .pair-form input[type="text"] {
        flex: none;
        width: 80%;
      }
    }

    section {
      padding: 0 2rem;
      margin: auto;
    }
  </style>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
</head>

<body>
  <header>
    <h1>ド天然のきゃたん</h1>
    <div class="hamburger" id="hamburger">☰</div>
    <nav id="nav">
      <a href="index.html">ホーム</a>
      <a href="roulette.html">イベント</a>
      <a href="team-view.html">チーム分けを見る</a>
      <a href="admin2.html">管理画面</a>
      <a href="team-maker.html">チーム分けする</a>
    </nav>
  </header>

  <h1>いい感じにチーム分けしてくれるやつ</h1>

  　<section>
    <div class="teams">
      <div class="team-box team1">
        <h2>チーム1</h2>
        <ul id="teamA"></ul>
      </div>
      <div class="team-box team2">
        <h2>チーム2</h2>
        <ul id="teamB"></ul>
      </div>
    </div>
  </section>
  
  <div id="allCandidatesContainer">
  <h2>全候補の組み合わせ</h2>
  <ul id="candidateList"></ul>
</div>

  <section>
    <div class="method-select">
      <label><input type="radio" name="method" value="average" checked> 平均キル</label>
      <label><input type="radio" name="method" value="winrate"> 勝率</label>
      <label><input type="radio" name="method" value="kdratio"> キルレ</label>
      <label><input type="radio" name="method" value="balanced"> 相性</label>
    </div>

    <div class="recent-toggle">
      <label><input type="checkbox" id="recentBiasToggle"> 直前試合重視(勝率除く)</label>
    </div>
  </section>

  <!-- ここからペア設定UI -->
  <section>
    <section class="pair-section" id="separatePairsSection">
      <h3>離したいペアを追加</h3>
      <form id="separatePairForm" class="pair-form" onsubmit="return false;">
        <input type="text" id="separateName1" placeholder="名前1" autocomplete="off" />
        <input type="text" id="separateName2" placeholder="名前2" autocomplete="off" />
        <button type="submit">追加</button>
      </form>
      <ul id="separatePairList" class="pair-list"></ul>
    </section>

    <section class="pair-section" id="togetherPairsSection">
      <h3>くっつけたいペアを追加</h3>
      <form id="togetherPairForm" class="pair-form" onsubmit="return false;">
        <input type="text" id="togetherName1" placeholder="名前1" autocomplete="off" />
        <input type="text" id="togetherName2" placeholder="名前2" autocomplete="off" />
        <button type="submit">追加</button>
      </form>
      <ul id="togetherPairList" class="pair-list"></ul>
    </section>
  </section>

  　<section>
    <div id="playerList" class="player-list"></div>
  </section>
  <p id="matchCount">過去 試合のカスタムマッチをもとに生成。</p>

  <footer>
    <p>ド天然のきゃたん</p>
  </footer>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyBbHLIr4GWkZ3Mfbg3M8wOY68X1ITrE-yw",
      authDomain: "match-result-ea475.firebaseapp.com",
      databaseURL: "https://match-result-ea475-default-rtdb.firebaseio.com",
      projectId: "match-result-ea475",
      storageBucket: "match-result-ea475.firebasestorage.app",
      messagingSenderId: "759877853492",
      appId: "1:759877853492:web:a10935960bf8230afbg3M8wOY68X1ITrE-yw"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    let matches = [];
    let playerScoresAverage = {}, playerScoresWinRate = {}, playerScoresKillDiff = {}, playerScoresKDRatio = {};
    let pinned = JSON.parse(localStorage.getItem("pinnedPlayers") || "[]");
    let matchingPlayers = [];

    // ペア設定配列
    let separatePairs = JSON.parse(localStorage.getItem("separatePairs") || "[]");
    let togetherPairs = JSON.parse(localStorage.getItem("togetherPairs") || "[]");

    // ペアUI操作関数
    function addPair(type, name1, name2) {
      name1 = name1.trim();
      name2 = name2.trim();
      if (!name1 || !name2 || name1 === name2) return false;
      const pair = [name1, name2].sort();
      let arr = (type === "separate") ? separatePairs : togetherPairs;

      // 重複チェック
      if (arr.some(p => p[0] === pair[0] && p[1] === pair[1])) return false;

      arr.push(pair);
      localStorage.setItem(type + "Pairs", JSON.stringify(arr));
      renderPairList(type);
      makeTeams();
      return true;
    }

    function removePair(type, index) {
      let arr = (type === "separate") ? separatePairs : togetherPairs;
      arr.splice(index, 1);
      localStorage.setItem(type + "Pairs", JSON.stringify(arr));
      renderPairList(type);
      makeTeams();
    }

    function renderPairList(type) {
      let arr = (type === "separate") ? separatePairs : togetherPairs;
      const listId = type === "separate" ? "separatePairList" : "togetherPairList";
      const ul = document.getElementById(listId);
      ul.innerHTML = "";
      arr.forEach((pair, i) => {
        const li = document.createElement("li");
        li.textContent = `${pair[0]} ＆ ${pair[1]}`;
        const btn = document.createElement("button");
        btn.className = "delete-btn";
        btn.textContent = "×";
        btn.onclick = () => removePair(type, i);
        li.appendChild(btn);
        ul.appendChild(li);
      });
    }

    // FirebaseからcurrentInputPlayersの監視（matchingPlayers更新）
    db.ref("currentInputPlayers").on("value", (snapshot) => {
      const data = snapshot.val() || {};
      matchingPlayers = [];

      Object.values(data).forEach(nameList => {
        if (Array.isArray(nameList)) {
          matchingPlayers.push(...nameList);
        }
      });

      matchingPlayers = [...new Set(matchingPlayers)];
      renderPlayers();
    });

    // スコア計算関数たち
    function calculateScoresAverage(matches) {
      const history = {};
      matches.forEach(match => {
        match.teamA?.forEach(p => {
          if (!history[p]) history[p] = [];
          history[p].push(match.teamAKills);
        });
        match.teamB?.forEach(p => {
          if (!history[p]) history[p] = [];
          history[p].push(match.teamBKills);
        });
      });

      const recentBias = document.getElementById("recentBiasToggle").checked;
      const scores = {};
      Object.keys(history).forEach(name => {
        const arr = history[name];
        if (arr.length === 0) { scores[name] = 0; return; }
        if (recentBias) {
          const last = arr[arr.length - 1];
          const prev = arr.slice(0, -1);
          const prevAvg = prev.length ? prev.reduce((a, b) => a + b, 0) / prev.length : 0;
          scores[name] = +(prevAvg + last).toFixed(2);
        } else {
          scores[name] = +(arr.reduce((a, b) => a + b, 0) / arr.length).toFixed(2);
        }
      });
      return scores;
    }

    function calculateWinRate(matches) {
      const stats = {};
      matches.forEach(match => {
        const teamAWins = match.teamAKills > match.teamBKills;
        match.teamA.forEach(p => {
          if (!stats[p]) stats[p] = { win: 0, total: 0 };
          stats[p].total++;
          if (teamAWins) stats[p].win++;
        });
        match.teamB.forEach(p => {
          if (!stats[p]) stats[p] = { win: 0, total: 0 };
          stats[p].total++;
          if (!teamAWins) stats[p].win++;
        });
      });
      const scores = {};
      Object.keys(stats).forEach(name => {
        scores[name] = +(stats[name].win / stats[name].total).toFixed(2);
      });
      return scores;
    }

    function calculateKDRatio(matches) {
      const playerStats = {};

      matches.forEach(match => {
        if (!match.teamA || !match.teamB) return;

        const teamAKills = match.teamAKills ?? 0;
        const teamBKills = match.teamBKills ?? 0;

        match.teamA.forEach(p => {
          if (!playerStats[p]) playerStats[p] = { kills: 0, deaths: 0 };
          playerStats[p].kills += teamAKills;
          playerStats[p].deaths += teamBKills;
        });

        match.teamB.forEach(p => {
          if (!playerStats[p]) playerStats[p] = { kills: 0, deaths: 0 };
          playerStats[p].kills += teamBKills;
          playerStats[p].deaths += teamAKills;
        });
      });

      const scores = {};
      Object.keys(playerStats).forEach(name => {
        const { kills, deaths } = playerStats[name];
        scores[name] = deaths === 0 ? kills : +(kills / deaths).toFixed(2);
      });
      return scores;
    }

    function calculateExpectedKDdiff(matches) {
      const stats = {}; // stats[playerA][playerB] = { asAlly, asEnemy }

      matches.forEach(match => {
        const teamA = match.teamA || [];
        const teamB = match.teamB || [];
        const killsA = match.teamAKills ?? 0;
        const killsB = match.teamBKills ?? 0;
        const kdDiffA = killsA - killsB;
        const kdDiffB = killsB - killsA;

        // teamA内ペア
        for (let i = 0; i < teamA.length; i++) {
          const pA = teamA[i];
          if (!stats[pA]) stats[pA] = {};
          for (let j = 0; j < teamA.length; j++) {
            if (i === j) continue;
            const pB = teamA[j];
            if (!stats[pA][pB]) stats[pA][pB] = { asAlly: [], asEnemy: [] };
            stats[pA][pB].asAlly.push(kdDiffA);
          }
          // 敵チームとの関係
          for (let j = 0; j < teamB.length; j++) {
            const pB = teamB[j];
            if (!stats[pA][pB]) stats[pA][pB] = { asAlly: [], asEnemy: [] };
            stats[pA][pB].asEnemy.push(kdDiffA);
          }
        }

        // teamB内ペア
        for (let i = 0; i < teamB.length; i++) {
          const pA = teamB[i];
          if (!stats[pA]) stats[pA] = {};
          for (let j = 0; j < teamB.length; j++) {
            if (i === j) continue;
            const pB = teamB[j];
            if (!stats[pA][pB]) stats[pA][pB] = { asAlly: [], asEnemy: [] };
            stats[pA][pB].asAlly.push(kdDiffB);
          }
          // 敵チームとの関係
          for (let j = 0; j < teamA.length; j++) {
            const pB = teamA[j];
            if (!stats[pA][pB]) stats[pA][pB] = { asAlly: [], asEnemy: [] };
            stats[pA][pB].asEnemy.push(kdDiffB);
          }
        }
      });

      // 平均化
      const expectedScores = {};
      Object.keys(stats).forEach(pA => {
        let total = 0, count = 0;
        Object.keys(stats[pA]).forEach(pB => {
          const data = stats[pA][pB];
          const allyAvg = data.asAlly.length ? data.asAlly.reduce((a, b) => a + b, 0) / data.asAlly.length : 0;
          const enemyAvg = data.asEnemy.length ? data.asEnemy.reduce((a, b) => a + b, 0) / data.asEnemy.length : 0;
          total += allyAvg - enemyAvg;  //allyAvg
          count++;
        });
        expectedScores[pA] = count ? +(total / count).toFixed(2) : 0;
      });

      return expectedScores;
    }

    // ピン留め切替
    function togglePin(name) {
      if (pinned.includes(name)) pinned = pinned.filter(x => x !== name);
      else pinned.push(name);
      localStorage.setItem("pinnedPlayers", JSON.stringify(pinned));
      renderPlayers();
      makeTeams();
    }

    // プレイヤー一覧描画
function renderPlayers() {
  const container = document.getElementById("playerList");
  const selected = Array.from(document.querySelectorAll(".player.selected")).map(d => d.dataset.name);
  const method = document.querySelector('input[name="method"]:checked').value;

  let scores;
  if (method === "average") scores = playerScoresAverage;
  else if (method === "winrate") scores = playerScoresWinRate;
  else if (method === "kdratio") scores = playerScoresKDRatio;
else if (method === "balanced") {
    scores = {};
    const source = Object.keys(playerScoresAverage); // 全プレイヤーを表示対象にする
    source.forEach(name => { scores[name] = 0; });
}

  container.innerHTML = "";
  let names = Object.keys(scores).filter(name => scores[name] !== undefined);

  const matchingOnlyPlayers = names.filter(name => matchingPlayers.includes(name))
    .sort((a, b) => a.localeCompare(b, "ja"));
  const pinnedOnlyPlayers = names.filter(name => pinned.includes(name) && !matchingPlayers.includes(name))
    .sort((a, b) => a.localeCompare(b, "ja"));
  const otherPlayers = names.filter(name => !matchingPlayers.includes(name) && !pinned.includes(name))
    .sort((a, b) => a.localeCompare(b, "ja"));

  const orderedNames = matchingOnlyPlayers.concat(pinnedOnlyPlayers, otherPlayers);

  orderedNames.forEach(name => {
    const div = document.createElement("div");
    div.className = "player";
    if (selected.includes(name)) div.classList.add("selected");
    else if (matchingPlayers.includes(name)) div.classList.add("matching");

    div.dataset.name = name;
    div.innerHTML = `<span>${name}</span><button class="pin-btn ${pinned.includes(name) ? "pinned" : ""}"></button>`;
    div.querySelector(".pin-btn").onclick = e => { e.stopPropagation(); togglePin(name); };
    div.onclick = () => {
      div.classList.toggle("selected");
      makeTeams();
      renderPlayers();
    };
    container.appendChild(div);
  });
}

    function makeTeams() {
      const selected = Array.from(document.querySelectorAll(".player.selected")).map(d => d.dataset.name);
      let scores;
      const method = document.querySelector('input[name="method"]:checked').value;

        if (method === "balanced") {
    makeBalancedTeams();
    return;
  }

      
      if (method === "average") scores = playerScoresAverage;
      else if (method === "winrate") scores = playerScoresWinRate;
      else if (method === "kdratio") scores = playerScoresKDRatio;
      else scores = {};

      if (selected.length === 0) {
        document.getElementById("teamA").innerHTML = "";
        document.getElementById("teamB").innerHTML = "";
        db.ref("currentTeamResult").set({ teamA: [], teamB: [], timestamp: Date.now() });
        return;
      }

      // 選択プレイヤーの強さ
      const players = selected
        .filter(name => scores[name] !== undefined) // undefined を除外
        .map(name => ({ name, strength: scores[name] ?? 0 }));

      // --- くっつけたいペアをグループ化 ---
      // union-find(Disjoint Set)でグループ分け
      class UnionFind {
        constructor(n) {
          this.parent = Array(n).fill(0).map((_, i) => i);
        }
        find(x) {
          if (this.parent[x] !== x) this.parent[x] = this.find(this.parent[x]);
          return this.parent[x];
        }
        union(a, b) {
          const rootA = this.find(a);
          const rootB = this.find(b);
          if (rootA !== rootB) this.parent[rootB] = rootA;
        }
      }

      const nameToIndex = {};
      players.forEach((p, i) => { nameToIndex[p.name] = i; });
      const uf = new UnionFind(players.length);

      togetherPairs.forEach(([n1, n2]) => {
        if (n1 in nameToIndex && n2 in nameToIndex) {
          uf.union(nameToIndex[n1], nameToIndex[n2]);
        }
      });

      // グループごとにメンバーと強さ合計をまとめる
      const groupsMap = new Map();
      players.forEach((p, i) => {
        const root = uf.find(i);
        if (!groupsMap.has(root)) groupsMap.set(root, { members: [], totalStrength: 0 });
        const g = groupsMap.get(root);
        g.members.push(p.name);
        g.totalStrength += p.strength;
      });
      const groups = Array.from(groupsMap.values());

      // 離したいペア
      const separate = separatePairs;

      // 全探索でチーム分け
      // groupsを単位にチーム分け。チームA,Bそれぞれにグループを割り当てていく
      function divideGroups(groups, separatePairs) {
        const results = [];
        const totalPlayers = groups.reduce((sum, g) => sum + g.members.length, 0);
        const minTeamSize = Math.floor(totalPlayers / 2);
        const maxTeamSize = Math.ceil(totalPlayers / 2);

        function dfs(index, teamAIndices, teamACount) {
          if (index === groups.length) {
            const teamBIndices = groups.map((_, i) => i).filter(i => !teamAIndices.includes(i));
            const teamAMembers = teamAIndices.flatMap(i => groups[i].members);
            const teamBMembers = teamBIndices.flatMap(i => groups[i].members);

            // 離したいペアが同じチームに居ないかチェック
            for (const [p1, p2] of separatePairs) {
              if ((teamAMembers.includes(p1) && teamAMembers.includes(p2)) ||
                (teamBMembers.includes(p1) && teamBMembers.includes(p2))) {
                return;
              }
            }

            // 人数差チェック
            const diff = Math.abs(teamAMembers.length - teamBMembers.length);
            if (diff > 1) return;

            const sumA = teamAMembers.reduce((sum, name) => sum + (scores[name] || 0), 0);
            const sumB = teamBMembers.reduce((sum, name) => sum + (scores[name] || 0), 0);

            results.push({ teamA: teamAMembers, teamB: teamBMembers, diffScore: sumA - sumB });
            return;
          }

          // チームAに追加
          dfs(index + 1, [...teamAIndices, index], teamACount + groups[index].members.length);
          // チームAに追加しない（チームBへ）
          dfs(index + 1, teamAIndices, teamACount);
        }

        dfs(0, [], 0);

        // 相性差が最小のものを返す
        results.sort((a, b) => a.diffScore - b.diffScore);
        return results[0] || null;
      }

      const best = divideGroups(groups, separate);

      if (!best) {
        document.getElementById("teamA").innerHTML = "<li>条件に合う分け方がありません</li>";
        document.getElementById("teamB").innerHTML = "";
        db.ref("currentTeamResult").set({ teamA: [], teamB: [], timestamp: Date.now() });
        return;
      }

      if (best.teamB.includes("きゃたん") && !best.teamA.includes("きゃたん")) {
        const temp = best.teamA;
        best.teamA = best.teamB;
        best.teamB = temp;
      }

      document.getElementById("teamA").innerHTML = best.teamA.map(n => `<li>${n}</li>`).join("");
      document.getElementById("teamB").innerHTML = best.teamB.map(n => `<li>${n}</li>`).join("");

      // ここでFirebaseに送信
      db.ref("currentTeamResult").set({
        teamA: best.teamA,
        teamB: best.teamB,
        timestamp: Date.now(),
      });
    }
    
async function makeBalancedTeams() {
  const selectedPlayers = Array.from(document.querySelectorAll(".player.selected")).map(p => p.dataset.name);
  if (selectedPlayers.length < 2) return;

  const snapshot = await db.ref("apex_results").once("value");
  if (!snapshot.exists()) return;
  const matches = Object.values(snapshot.val());

  const teamSize = Math.floor(selectedPlayers.length / 2);
  const combinations = getCombinations(selectedPlayers, teamSize);

  const candidates = [];

  let bestDiff = Infinity;
  let bestTeams = null;

  combinations.forEach(teamA => {
    const teamB = selectedPlayers.filter(p => !teamA.includes(p));
    const scoreA = calcTeamScore(teamA, teamB, matches);
    const scoreB = calcTeamScore(teamB, teamA, matches);
    const diff = scoreA - scoreB;

    candidates.push({ teams: { A: teamA, B: teamB }, scoreDiff: diff });

if (Math.abs(diff) < Math.abs(bestDiff)) {
  bestDiff = diff;  // ← diff は符号付きのまま保持
  bestTeams = { teamA, teamB };
}
  });

  displayCandidates(candidates); // ←ここで全候補リストを表示

  document.getElementById("teamA").innerHTML = bestTeams.teamA.map(n => `<li>${n}</li>`).join("");
  document.getElementById("teamB").innerHTML = bestTeams.teamB.map(n => `<li>${n}</li>`).join("");
  db.ref("currentTeamResult").set({
    teamA: bestTeams.teamA,
    teamB: bestTeams.teamB,
    timestamp: Date.now(),
  });
}

// 他の補助関数も上で書いたものをそのまま利用
function getCombinations(array, size) {
  if (size === 0) return [[]];
  if (array.length < size) return [];
  const [first, ...rest] = array;
  const combsWithFirst = getCombinations(rest, size - 1).map(c => [first, ...c]);
  const combsWithoutFirst = getCombinations(rest, size);
  return combsWithFirst.concat(combsWithoutFirst);
}

function calcTeamScore(team, opposingTeam, matches) {
  let score = 0;

  team.forEach(p => {
    let total = 0;
    let count = 0;

    // 味方との過去試合
    team.forEach(ally => {
      if (ally === p) return; // 自分自身はスキップ
      matches.forEach(match => {
        const teamA = match.teamA || [];
        const teamB = match.teamB || [];

        // 現在の味方なら過去も味方だった試合のみ
        if ((teamA.includes(p) && teamA.includes(ally)) || (teamB.includes(p) && teamB.includes(ally))) {
          const diff = teamA.includes(p) ? (match.teamAKills ?? 0) - (match.teamBKills ?? 0) 
                                        : (match.teamBKills ?? 0) - (match.teamAKills ?? 0);
          total += diff;
          count++;
        }
      });
    });

    // 敵との過去試合
    opposingTeam.forEach(enemy => {
      matches.forEach(match => {
        const teamA = match.teamA || [];
        const teamB = match.teamB || [];

        // 現在の敵なら過去も敵だった試合のみ
        if ((teamA.includes(p) && teamB.includes(enemy)) || (teamB.includes(p) && teamA.includes(enemy))) {
          const diff = teamA.includes(p) ? (match.teamAKills ?? 0) - (match.teamBKills ?? 0)
                                        : (match.teamBKills ?? 0) - (match.teamAKills ?? 0);
          total += diff;
          count++;
        }
      });
    });

    if (count > 0) score += Number((total / count).toFixed(1));
  });

  return score;
}

// 使う時は呼び出すだけ
document.getElementById("makeBalancedTeamsBtn")?.addEventListener("click", makeBalancedTeams);
    // ペアフォーム イベント設定
    document.getElementById("separatePairForm").addEventListener("submit", e => {
      e.preventDefault();
      const n1 = document.getElementById("separateName1").value;
      const n2 = document.getElementById("separateName2").value;
      if (addPair("separate", n1, n2)) {
        document.getElementById("separateName1").value = "";
        document.getElementById("separateName2").value = "";
      } else {
        alert("名前が空欄か同じ、もしくは既に登録済みです。");
      }
    });

    document.getElementById("togetherPairForm").addEventListener("submit", e => {
      e.preventDefault();
      const n1 = document.getElementById("togetherName1").value;
      const n2 = document.getElementById("togetherName2").value;
      if (addPair("together", n1, n2)) {
        document.getElementById("togetherName1").value = "";
        document.getElementById("togetherName2").value = "";
      } else {
        alert("名前が空欄か同じ、もしくは既に登録済みです。");
      }
    });

    // マッチ履歴取得とスコア計算
    db.ref("apex_results").on("value", snapshot => {
      if (!snapshot.exists()) return;
      matches = Object.values(snapshot.val());
      playerScoresAverage = calculateScoresAverage(matches);
      playerScoresWinRate = calculateWinRate(matches);
      playerScoresKDRatio = calculateKDRatio(matches);
      playerScoresExpectedKDdiff = calculateExpectedKDdiff(matches);
      renderPlayers();
      makeTeams();
      document.getElementById("matchCount").textContent = `過去${matches.length}試合のカスタムマッチをもとに生成。`;
    });

    // ラジオボタンとチェックボックス変化時イベント
    document.querySelectorAll('input[name="method"]').forEach(radio => {
      radio.addEventListener("change", () => {
        makeTeams();
        renderPlayers();
      });
    });

    document.getElementById("recentBiasToggle").addEventListener("change", () => {
      if (document.querySelector('input[name="method"]:checked').value !== "winrate") {
        // 勝率以外のときのみ再計算
        playerScoresAverage = calculateScoresAverage(matches);
        playerScoresKillDiff = calculateKillDiff(matches);
        renderPlayers();
        makeTeams();
      }
    });

    // ペアリスト初期描画
    renderPairList("separate");
    renderPairList("together");

    const hamburger = document.getElementById("hamburger");
    const nav = document.getElementById("nav");

    hamburger.addEventListener("click", () => {
      nav.classList.toggle("show");

      const links = nav.querySelectorAll("a");
      links.forEach((link, index) => {
        if (nav.classList.contains("show")) {
          link.style.opacity = "1";
          link.style.transform = "translateY(0)";
          link.style.transitionDelay = `${index * 0.1}s`; // 順番に遅延
        } else {
          link.style.opacity = "0";
          link.style.transform = "translateY(-20px)";
          link.style.transitionDelay = "0s";
        }
      });
    });

document.querySelectorAll('input[name="method"]').forEach(radio => {
  radio.addEventListener("change", async () => {  // asyncを付ける
    if (radio.value === "balanced") {
      await makeBalancedTeams();  // 非同期で呼ぶ
    } else {
      makeTeams();       // 他のモードは普通に呼ぶ
      renderPlayers();   // 表示も更新
    }
  });
});

function displayCandidates(candidates) {
  const container = document.getElementById("candidateList");
  container.innerHTML = "";

  candidates.forEach((cand, idx) => {
    const li = document.createElement("li");

    // チームAとBのメンバー名＋スコア
    const teamAScores = cand.teams.A.map(name => {
      const score = calcPlayerScore(name, cand.teams.A, cand.teams.B);
      return `${name} (${score})`;
    }).join(", ");

    const teamBScores = cand.teams.B.map(name => {
      const score = calcPlayerScore(name, cand.teams.B, cand.teams.A);
      return `${name} (${score})`;
    }).join(", ");

    li.innerHTML = `<strong>候補${idx+1}:</strong><br>
                    チームA: ${teamAScores}<br>
                    チームB: ${teamBScores}<br>
                    差: ${cand.scoreDiff.toFixed(1)}`;
    container.appendChild(li);
  });
}
  </script>
</body>

</html>