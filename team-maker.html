<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="IMG_4666.png" type="image/png">
  <meta property="og:image" content="https://www.yourwebsite.com/ç„¡é¡Œ12_20250907003655.jpeg">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
  <title>ã„ã„æ„Ÿã˜ã«ãƒãƒ¼ãƒ åˆ†ã‘ã—ã¦ãã‚Œã‚‹ã‚„ã¤</title>
  
  <link rel="stylesheet" href="common.css">
</head>

<body>
  <div id="header-placeholder"></div>

  <main>
    <div class="container">
      <h1>ã„ã„æ„Ÿã˜ã«ãƒãƒ¼ãƒ åˆ†ã‘ã—ã¦ãã‚Œã‚‹ã‚„ã¤</h1>

      <section>
        <div class="teams">
          <div class="team-box team1">
            <h2>ãƒãƒ¼ãƒ 1</h2>
            <ul id="teamA"></ul>
            <p class="score-display">åˆè¨ˆã‚¹ã‚³ã‚¢: <span id="teamAScore">0</span></p>
          </div>
          <div class="team-box team2">
            <h2>ãƒãƒ¼ãƒ 2</h2>
            <ul id="teamB"></ul>
            <p class="score-display">åˆè¨ˆã‚¹ã‚³ã‚¢: <span id="teamBScore">0</span></p>
          </div>
        </div>
      </section>
      
      <section>
        <div class="method-select">
          <label><input type="radio" name="method" value="average" checked> å¹³å‡ã‚­ãƒ«</label>
          <label><input type="radio" name="method" value="balanced"> ç›¸æ€§</label>
          <label><input type="radio" name="method" value="kdratio"> ã‚­ãƒ«ãƒ¬</label>
          <label><input type="radio" name="method" value="winrate"> å‹ç‡</label>
        </div>
      </section>

      <section>
        <section class="pair-section" id="separatePairsSection">
          <h3>é›¢ã—ãŸã„ãƒšã‚¢ã‚’è¿½åŠ </h3>
          <form id="separatePairForm" class="pair-form" onsubmit="return false;">
            <input type="text" id="separateName1" placeholder="åå‰1" autocomplete="off" />
            <input type="text" id="separateName2" placeholder="åå‰2" autocomplete="off" />
            <button type="submit">è¿½åŠ </button>
          </form>
          <ul id="separatePairList" class="pair-list"></ul>
        </section>

        <section class="pair-section" id="togetherPairsSection">
          <h3>ãã£ã¤ã‘ãŸã„ãƒšã‚¢ã‚’è¿½åŠ </h3>
          <form id="togetherPairForm" class="pair-form" onsubmit="return false;">
            <input type="text" id="togetherName1" placeholder="åå‰1" autocomplete="off" />
            <input type="text" id="togetherName2" placeholder="åå‰2" autocomplete="off" />
            <button type="submit">è¿½åŠ </button>
          </form>
          <ul id="togetherPairList" class="pair-list"></ul>
        </section>
      </section>
      
      <label for="playerSearchInput">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ¤œç´¢ï¼ˆæ”¹è¡Œã§åŒºåˆ‡ã‚‹ï¼‰</label>
      <textarea id="playerSearchInput" rows="6"></textarea>

      <section>
        <div class="sort-buttons">
          <button id="sort-reading" class="active">50éŸ³é †</button>
          <button id="sort-recent">æœ€è¿‘ãƒ—ãƒ¬ã‚¤ã—ãŸé †</button>
          <button id="sort-count">å‚åŠ å›æ•°é †</button>
        </div>
        <div id="playerList" class="player-list"></div>
      </section>
      <p id="matchCount">éå» è©¦åˆã®ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒã‚’ã‚‚ã¨ã«ç”Ÿæˆã€‚</p>

      <section id="allCombinationsSection">
        <h2>ã™ã¹ã¦ã®ãƒãƒ¼ãƒ åˆ†ã‘å€™è£œ</h2>
        <ul id="allCombinationsList"></ul>
      </section>

    </div>
  </main>

  <div id="footer-placeholder"></div>

  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  
  <script src="common.js"></script>

  <script>
    // ----------------------------------------------------------------------
    // â˜…è¿½åŠ : å…±é€šå‡¦ç†ã®å‘¼ã³å‡ºã— â˜…
    // ----------------------------------------------------------------------
    document.addEventListener("DOMContentLoaded", () => {
        // ç®¡ç†è€…ç”¨ãƒ˜ãƒƒãƒ€ãƒ¼ï¼ˆheader-admin.htmlãªã©ï¼‰ã‚’èª­ã¿è¾¼ã‚€
        // ğŸš¨ ä»¥å‰ã®ãƒ˜ãƒƒãƒ€ãƒ¼ã¯ "ã‚«ã‚¹ã‚¿ãƒãƒ¼ã‚»ãƒ³ã‚¿ãƒ¼ã®ãã‚ƒãŸã‚“" ã§ã—ãŸãŒã€ã“ã®ãƒšãƒ¼ã‚¸ã§ã¯ "ãƒ‰å¤©ç„¶ã®ãã‚ƒãŸã‚“" ãŒä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚
        // ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ã”è‡ªèº«ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«åˆã‚ã›ã¦å¤‰æ›´ã—ã¦ãã ã•ã„ã€‚
        // ã“ã“ã§ã¯ä»®ã« 'header-admin-team.html' ã¨ã—ã€ç®¡ç†è€…ãƒªãƒ³ã‚¯ã‚’æŒã¤ã¨æƒ³å®šã—ã¾ã™ã€‚
        setupHeader('header-admin.html'); 
        
        // ãƒšãƒ¼ã‚¸å›ºæœ‰ã®åˆæœŸåŒ–ãƒ­ã‚¸ãƒƒã‚¯
        initializePage();
    });
    // ----------------------------------------------------------------------
    
    const firebaseConfig = {
      apiKey: "AIzaSyBbHLIr4GWkZ3Mfbg3M8wOY68X1ITrE-yw",
      authDomain: "match-result-ea475.firebaseapp.com",
      databaseURL: "https://match-result-ea475-default-rtdb.firebaseio.com",
      projectId: "match-result-ea475",
      storageBucket: "match-result-ea475.firebasestorage.app",
      messagingSenderId: "759877853492",
      appId: "1:759877853492:web:a10935960bf8230af90561"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    // ... (ä»¥é™ã®å…¨ã¦ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯å¤‰æ›´ãªã—ã§ãã®ã¾ã¾æ®‹ã—ã¾ã™) ...
    function getDeviceId() {
      let baseId = localStorage.getItem("deviceId");
      if (!baseId) {
        baseId = "device_" + Date.now() + "_" + Math.floor(Math.random() * 10000);
        localStorage.setItem("deviceId", baseId);
      }
      return baseId;
    }
    const deviceId = getDeviceId();
    
    // é¸æŠã•ã‚ŒãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã€ãƒšã‚¢ã®æƒ…å ±ã‚’localStorageã‹ã‚‰èª­ã¿è¾¼ã¾ãªã„ã‚ˆã†ã«å¤‰æ›´
    let selectedPlayers = [];
    let pinned = JSON.parse(localStorage.getItem("pinnedPlayers") || "[]");
    let separatePairs = [];
    let togetherPairs = [];

    function katakanaToHiragana(str) {
      return str.replace(/[\u30a1-\u30f6]/g, function(match) {
        return String.fromCharCode(match.charCodeAt(0) - 0x60);
      });
    }
    
    let matches = [];
    let playerScoresAverage = {},
      playerScoresWinRate = {},
      playerScoresKDRatio = {};
    
    let firebaseMatchingPlayers = [];
    let playerSearchInputNames = []; 
    let matchingPlayers = [];
    
    let allPlayersList = [];
    let playerPlayDates = {};
    let playerPlayCounts = {};
    let currentSortMode = 'reading';

    let playerAliasMap = {};
    let readingsData = {};

    let debounceTimer;
    document.getElementById("playerSearchInput").addEventListener("input", () => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
            const inputStr = document.getElementById("playerSearchInput").value;
            const inputNames = inputStr.split(/\n/).map(name => name.trim()).filter(name => name !== '');
            
            playerSearchInputNames = inputNames.filter(name => {
                const normalizedName = katakanaToHiragana(name).toLowerCase();
                const resolvedName = playerAliasMap[normalizedName] || name;
                
                return allPlayersList.includes(resolvedName);
            });
            updateMatchingPlayers(); 
        }, 300);
    });
    
    db.ref("currentInputPlayers").on("value", (snapshot) => {
        const data = snapshot.val() || {};
        const now = Date.now();
        const playersToKeep = {};
        const playerKeysToRemove = [];

        for (const deviceId in data) {
            const deviceData = data[deviceId];
            if (deviceData.timestamp && (now - deviceData.timestamp) < 3600000) { // 1æ™‚é–“ã®ä¾‹
                if (Array.isArray(deviceData.players)) {
                    playersToKeep[deviceId] = deviceData.players;
                }
            } else {
                playerKeysToRemove.push(deviceId);
            }
        }

        if (playerKeysToRemove.length > 0) {
            playerKeysToRemove.forEach(key => {
                db.ref("currentInputPlayers").child(key).remove();
            });
        }
        
        firebaseMatchingPlayers = [];
        Object.values(playersToKeep).forEach(nameList => {
            if (Array.isArray(nameList)) {
                nameList.forEach(name => {
                    if (name && name.trim() !== '') {
                        firebaseMatchingPlayers.push(name.trim());
                    }
                });
            }
        });

        updateMatchingPlayers(); 
    });

    function updateMatchingPlayers() {
      const mergedList = [...firebaseMatchingPlayers, ...playerSearchInputNames];
      const resolvedList = resolveAliases(mergedList);
      matchingPlayers = [...new Set(resolvedList)];
      renderPlayers();
      makeTeams();
    }


    function addPair(type, name1, name2) {
      name1 = name1.trim();
      name2 = name2.trim();
      if (!name1 || !name2 || name1 === name2) return false;
      const pair = [name1, name2].sort();
      let arr = (type === "separate") ? separatePairs : togetherPairs;

      if (arr.some(p => p[0] === pair[0] && p[1] === pair[1])) return false;

      arr.push(pair);
      renderPairList(type);
      makeTeams();
      return true;
    }

    function removePair(type, index) {
      let arr = (type === "separate") ? separatePairs : togetherPairs;
      arr.splice(index, 1);
      renderPairList(type);
      makeTeams();
    }

    function renderPairList(type) {
      let arr = (type === "separate") ? separatePairs : togetherPairs;
      const listId = type === "separate" ? "separatePairList" : "togetherPairList";
      const ul = document.getElementById(listId);
      ul.innerHTML = "";
      arr.forEach((pair, i) => {
        const li = document.createElement("li");
        li.textContent = `${pair[0]} ï¼† ${pair[1]}`;
        const btn = document.createElement("button");
        btn.className = "delete-btn";
        btn.textContent = "Ã—";
        btn.onclick = () => removePair(type, i);
        li.appendChild(btn);
        ul.appendChild(li);
      });
    }

    function calculateScoresAverage(matches) {
      const history = {};
      matches.forEach(match => {
        match.teamA?.forEach(p => {
          if (!history[p]) history[p] = [];
          history[p].push(match.teamAKills);
        });
        match.teamB?.forEach(p => {
          if (!history[p]) history[p] = [];
          history[p].push(match.teamBKills);
        });
      });

      const scores = {};
      Object.keys(history).forEach(name => {
        const arr = history[name];
        if (arr.length === 0) {
          scores[name] = 0;
          return;
        }
        scores[name] = +(arr.reduce((a, b) => a + b, 0) / arr.length).toFixed(2);
      });
      return scores;
    }

    function calculateWinRate(matches) {
      const stats = {};
      matches.forEach(match => {
        const teamAWins = (match.teamAKills ?? 0) > (match.teamBKills ?? 0);
        match.teamA?.forEach(p => {
          if (!stats[p]) stats[p] = {
            win: 0,
            total: 0
          };
          stats[p].total++;
          if (teamAWins) stats[p].win++;
        });
        match.teamB?.forEach(p => {
          if (!stats[p]) stats[p] = {
            win: 0,
            total: 0
          };
          stats[p].total++;
          if (!teamAWins) stats[p].win++;
        });
      });
      const scores = {};
      Object.keys(stats).forEach(name => {
        scores[name] = +(stats[name].win / stats[name].total).toFixed(2);
      });
      return scores;
    }

    function calculateKDRatio(matches) {
      const playerStats = {};

      matches.forEach(match => {
        if (!match.teamA || !match.teamB) return;

        const teamAKills = match.teamAKills ?? 0;
        const teamBKills = match.teamBKills ?? 0;

        match.teamA.forEach(p => {
          if (!playerStats[p]) playerStats[p] = {
            kills: 0,
            deaths: 0
          };
          playerStats[p].kills += teamAKills;
          playerStats[p].deaths += teamBKills;
        });

        match.teamB.forEach(p => {
          if (!playerStats[p]) playerStats[p] = {
            kills: 0,
            deaths: 0
          };
          playerStats[p].kills += teamBKills;
          playerStats[p].deaths += teamAKills;
        });
      });

      const scores = {};
      Object.keys(playerStats).forEach(name => {
        const {
          kills,
          deaths
        } = playerStats[name];
        scores[name] = deaths === 0 ? kills : +(kills / deaths).toFixed(2);
      });
      return scores;
    }

    function togglePin(name) {
      if (pinned.includes(name)) {
        pinned = pinned.filter(x => x !== name);
      } else {
        pinned.push(name);
      }
      localStorage.setItem("pinnedPlayers", JSON.stringify(pinned));
      renderPlayers();
      makeTeams();
    }
    
    function sortPlayers(names, readings, sortMode) {
      if (sortMode === 'reading') {
        return names.sort((a, b) => {
          const readingA = katakanaToHiragana(readings[a]?.reading || a);
          const readingB = katakanaToHiragana(readings[b]?.reading || b);
          return readingA.localeCompare(readingB, "ja");
        });
      } else if (sortMode === 'recent') {
        return names.sort((a, b) => {
          const dateA = playerPlayDates[a] || 0;
          const dateB = playerPlayDates[b] || 0;
          return dateB - dateA;
        });
      } else if (sortMode === 'count') {
        return names.sort((a, b) => {
          const countA = playerPlayCounts[a] || 0;
          const countB = playerPlayCounts[b] || 0;
          return countB - countA;
        });
      }
      return names;
    }

    async function renderPlayers() {
      const container = document.getElementById("playerList");
      
      container.innerHTML = "";
      
      const sortedAllPlayers = sortPlayers(allPlayersList, readingsData, currentSortMode);

      const matchingAndPinned = sortedAllPlayers.filter(name => matchingPlayers.includes(name) && pinned.includes(name));
      const matchingNotPinned = sortedAllPlayers.filter(name => matchingPlayers.includes(name) && !pinned.includes(name));
      const pinnedNotMatching = sortedAllPlayers.filter(name => pinned.includes(name) && !matchingPlayers.includes(name));
      const others = sortedAllPlayers.filter(name => !matchingPlayers.includes(name) && !pinned.includes(name));

      const finalSortedList = [...matchingAndPinned, ...matchingNotPinned, ...pinnedNotMatching, ...others];
      
      finalSortedList.forEach(name => {
        const div = document.createElement("div");
        div.className = "player";
        
        if (selectedPlayers.includes(name)) {
          div.classList.add("selected");
          div.classList.remove("matching"); 
        } else if (matchingPlayers.includes(name) && matchingPlayers.length > 0) {
          div.classList.add("matching");
        }
        
        div.dataset.name = name;
        div.innerHTML = `<span>${name}</span><button class="pin-btn ${pinned.includes(name) ? "pinned" : ""}" title="å›ºå®š/å›ºå®šè§£é™¤"></button>`;
        
        div.querySelector(".pin-btn").onclick = e => {
          e.stopPropagation();
          togglePin(name);
        };
        div.onclick = () => {
          const isSelected = div.classList.contains("selected");
          if (isSelected) {
            selectedPlayers = selectedPlayers.filter(n => n !== name);
          } else {
            selectedPlayers.push(name);
          }
          renderPlayers();
          makeTeams();
        };
        container.appendChild(div);
      });
    }

    async function makeTeams() {
      const players = selectedPlayers;
      const method = document.querySelector('input[name="method"]:checked').value;

      const teamAScoreEl = document.getElementById("teamAScore");
      const teamBScoreEl = document.getElementById("teamBScore");
      const allCombinationsList = document.getElementById("allCombinationsList");

      teamAScoreEl.textContent = "0";
      teamBScoreEl.textContent = "0";
      allCombinationsList.innerHTML = "";

      if (players.length === 0) {
        document.getElementById("teamA").innerHTML = "";
        document.getElementById("teamB").innerHTML = "";
        db.ref("currentTeamResult").set({
          teamA: [],
          teamB: [],
          timestamp: Date.now()
        });
        return;
      }

      const separate = separatePairs;
      const together = togetherPairs;

      // UnionFindã®å®šç¾©
      class UnionFind {
        constructor(n) {
          this.parent = Array(n).fill(0).map((_, i) => i);
        }
        find(x) {
          if (this.parent[x] !== x) this.parent[x] = this.find(this.parent[x]);
          return this.parent[x];
        }
        union(a, b) {
          const rootA = this.find(a);
          const rootB = this.find(b);
          if (rootA !== rootB) this.parent[rootB] = rootA;
        }
      }

      // ãƒãƒ¼ãƒ åˆ†ã‘ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
      async function divideGroups() {
        let bestResult = null;
        let bestDiff = Infinity;
        const allCombinations = [];

        // ãã£ã¤ã‘ãŸã„ãƒšã‚¢ã«ã‚ˆã‚‹ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
        const nameToIndex = {};
        players.forEach((p, i) => {
          nameToIndex[p] = i;
        });
        const uf = new UnionFind(players.length);

        together.forEach(([n1, n2]) => {
          const index1 = nameToIndex[n1];
          const index2 = nameToIndex[n2];
          if (index1 !== undefined && index2 !== undefined) {
            uf.union(index1, index2);
          }
        });

        const groupsMap = new Map();
        players.forEach((p, i) => {
          const root = uf.find(i);
          if (!groupsMap.has(root)) groupsMap.set(root, []);
          groupsMap.get(root).push(p);
        });
        const groups = Array.from(groupsMap.values());

        const totalPlayers = players.length;
        const isEven = totalPlayers % 2 === 0;
        const targetSizeA = isEven ? totalPlayers / 2 : Math.floor(totalPlayers / 2);

        const combinations = getCombinations(groups, totalPlayers);
        
        for (const comb of combinations) {
          const teamAGroups = comb;
          const teamBGroups = groups.filter(g => !comb.includes(g));

          const teamAMembers = teamAGroups.flat();
          const teamBMembers = teamBGroups.flat();
          
          // äººæ•°ãƒãƒ©ãƒ³ã‚¹ã®ãƒã‚§ãƒƒã‚¯ (å¥‡æ•°ã®å ´åˆã¯äººæ•°ãŒ1äººãšã‚Œã‚‹)
          if (Math.abs(teamAMembers.length - teamBMembers.length) > 1) continue;

          // é›¢ã—ãŸã„ãƒšã‚¢ã®æ¡ä»¶ãƒã‚§ãƒƒã‚¯
          let isValid = true;
          for (const [p1, p2] of separate) {
            const p1InA = teamAMembers.includes(p1);
            const p2InA = teamAMembers.includes(p2);
            const p1InB = teamBMembers.includes(p1);
            const p2InB = teamBMembers.includes(p2);
            if ((p1InA && p2InA) || (p1InB && p2InB)) {
              isValid = false;
              break;
            }
          }
          if (!isValid) continue;

          // ã“ã“ã‹ã‚‰ã‚¹ã‚³ã‚¢è¨ˆç®—
          let scoreA, scoreB, diffScore;
          let individualScores;
          if (method === "balanced") {
            individualScores = calculateBalancedScores(teamAMembers, teamBMembers, matches);
            scoreA = teamAMembers.reduce((sum, name) => sum + (individualScores[name] || 0), 0);
            scoreB = teamBMembers.reduce((sum, name) => sum + (individualScores[name] || 0), 0);
            diffScore = Math.abs(scoreA - scoreB);
          } else {
            if (method === "average") individualScores = playerScoresAverage;
            else if (method === "winrate") individualScores = playerScoresWinRate;
            else individualScores = playerScoresKDRatio;

            scoreA = teamAMembers.reduce((sum, name) => sum + (individualScores[name] || 0), 0);
            scoreB = teamBMembers.reduce((sum, name) => sum + (individualScores[name] || 0), 0);
            diffScore = Math.abs(scoreA - scoreB);
          }

          allCombinations.push({
            teamA: teamAMembers,
            teamB: teamBMembers,
            diffScore,
            scoreA,
            scoreB,
            individualScores
          });

          if (bestResult === null || diffScore < bestDiff) {
            bestDiff = diffScore;
            bestResult = {
              teamA: teamAMembers,
              teamB: teamBMembers,
              diffScore,
              scoreA,
              scoreB,
              individualScores
            };
          }
        }
        return {
            bestResult,
            allCombinations
        };
      }

      const {
        bestResult,
        allCombinations
      } = await divideGroups();

      if (!bestResult) {
        document.getElementById("teamA").innerHTML = "<li>æ¡ä»¶ã«åˆã†åˆ†ã‘æ–¹ãŒã‚ã‚Šã¾ã›ã‚“</li>";
        document.getElementById("teamB").innerHTML = "";
        teamAScoreEl.textContent = "0";
        teamBScoreEl.textContent = "0";
        db.ref("currentTeamResult").set({
          teamA: [],
          teamB: [],
          timestamp: Date.now()
        });
        return;
      }

      if (bestResult.teamB.includes("ãƒ‰å¤©ç„¶ã®ãã‚ƒãŸã‚“") && !bestResult.teamA.includes("ãƒ‰å¤©ç„¶ã®ãã‚ƒãŸã‚“")) {
        const temp = bestResult.teamA;
        bestResult.teamA = bestResult.teamB;
        bestResult.teamB = temp;
        const tempScore = bestResult.scoreA;
        bestResult.scoreA = bestResult.scoreB;
        bestResult.scoreB = tempScore;
      }

      document.getElementById("teamA").innerHTML = bestResult.teamA.map(n => `<li>${n} (${(bestResult.individualScores[n] || 0).toFixed(2)})</li>`).join("");
      document.getElementById("teamB").innerHTML = bestResult.teamB.map(n => `<li>${n} (${(bestResult.individualScores[n] || 0).toFixed(2)})</li>`).join("");

      db.ref("currentTeamResult").set({
        teamA: bestResult.teamA,
        teamB: bestResult.teamB,
        timestamp: Date.now(),
      });

      teamAScoreEl.textContent = bestResult.scoreA.toFixed(2);
      teamBScoreEl.textContent = bestResult.scoreB.toFixed(2);

      allCombinations.sort((a, b) => a.diffScore - b.diffScore);
      allCombinationsList.innerHTML = "";
      allCombinations.forEach(combination => {
        const li = document.createElement("li");
        const diffText = `ã‚¹ã‚³ã‚¢å·®: ${combination.diffScore.toFixed(2)}`;
        const teamAPlayers = combination.teamA.map(n => `${n}(${(combination.individualScores[n] || 0).toFixed(2)})`).join(", ");
        const teamBPlayers = combination.teamB.map(n => `${n}(${(combination.individualScores[n] || 0).toFixed(2)})`).join(", ");

        li.innerHTML = `
          <strong>ãƒãƒ¼ãƒ A</strong>: ${teamAPlayers}<br>
          <strong>ãƒãƒ¼ãƒ B</strong>: ${teamBPlayers}<br>
          ${diffText}
        `;
        allCombinationsList.appendChild(li);
      });
    }

    function calculateBalancedScores(teamA, teamB, matches) {
      const scores = {};
      const allPlayers = [...teamA, ...teamB];
      allPlayers.forEach(p => scores[p] = 0);

      allPlayers.forEach(p1 => {
        const p1IsA = teamA.includes(p1);
        let p1Score = 0;

        allPlayers.forEach(p2 => {
          if (p1 === p2) return;
          const p2IsA = teamA.includes(p2);
          let interactionScore = 0;
          let interactionCount = 0;

          matches.forEach(match => {
            const matchTeamA = match.teamA || [];
            const matchTeamB = match.teamB || [];
            const p1InMatch = matchTeamA.includes(p1) || matchTeamB.includes(p1);
            const p2InMatch = matchTeamA.includes(p2) || matchTeamB.includes(p2);
            
            if (!p1InMatch || !p2InMatch) {
                return;
            }

            const p1InMatchA = matchTeamA.includes(p1);
            const p2InMatchA = matchTeamA.includes(p2);

            if ((p1InMatchA && p2InMatchA) || (!p1InMatchA && !p2InMatchA)) {
              if (p1IsA === p2IsA) { 
                const diff = (p1InMatchA ? (match.teamAKills ?? 0) - (match.teamBKills ?? 0) : (match.teamBKills ?? 0) - (match.teamAKills ?? 0));
                interactionScore += diff;
                interactionCount++;
              }
            }
            else {
              if (p1IsA !== p2IsA) { 
                const diff = (p1InMatchA ? (match.teamAKills ?? 0) - (match.teamBKills ?? 0) : (match.teamBKills ?? 0) - (match.teamAKills ?? 0));
                interactionScore += diff;
                interactionCount++;
              }
            }
          });

          if (interactionCount > 0) {
            p1Score += interactionScore / interactionCount;
          }
        });
        scores[p1] = p1Score;
      });

      return scores;
    }

    function getCombinations(array, totalPlayers) {
      const result = [];
      const targetSize = Math.floor(totalPlayers / 2);
      const isEven = totalPlayers % 2 === 0;

      function backtrack(tempList, start, currentSize) {
        if (currentSize > targetSize + (isEven ? 0 : 1)) {
          return;
        }

        if (currentSize === targetSize || (!isEven && currentSize === targetSize + 1)) {
          // äººæ•°ãŒã¡ã‚‡ã†ã©åŠåˆ† (ã¾ãŸã¯åŠåˆ†+1) ã«ãªã‚‹çµ„ã¿åˆã‚ã›ã ã‘ã‚’è€ƒæ…®
          const members = tempList.flat();
          const otherMembers = array.filter(group => !tempList.includes(group)).flat();

          // ãƒãƒ¼ãƒ ã®åˆè¨ˆäººæ•°ã‚’å†ç¢ºèª
          if (members.length + otherMembers.length !== totalPlayers) {
              return;
          }

          // ãƒãƒ¼ãƒ Aã¨ãƒãƒ¼ãƒ Bã®äººæ•°å·®ãŒ1ä»¥ä¸‹ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
          if (Math.abs(members.length - otherMembers.length) > 1) {
              return;
          }

          result.push(tempList);
          return;
        }

        for (let i = start; i < array.length; i++) {
          backtrack([...tempList, array[i]], i + 1, currentSize + array[i].length);
        }
      }
      
      backtrack([], 0, 0);

      // å¶æ•°äººã®å ´åˆã®ã¿é‡è¤‡ã‚’æ’é™¤
      if (isEven) {
        const seen = new Set();
        const uniqueCombinations = [];
        
        for (const comb of result) {
          const flatComb = comb.flat().sort().join(',');
          const flatOther = array.filter(group => !comb.includes(group)).flat().sort().join(',');
          
          if (!seen.has(flatComb) && !seen.has(flatOther)) {
            seen.add(flatComb);
            seen.add(flatOther);
            uniqueCombinations.push(comb);
          }
        }
        return uniqueCombinations;
      }
      
      return result;
    }

    document.getElementById("separatePairForm").addEventListener("submit", e => {
      e.preventDefault();
      const n1 = document.getElementById("separateName1").value;
      const n2 = document.getElementById("separateName2").value;
      if (addPair("separate", n1, n2)) {
        document.getElementById("separateName1").value = "";
        document.getElementById("separateName2").value = "";
      } else {
        alert("åå‰ãŒç©ºæ¬„ã‹åŒã˜ã€ã‚‚ã—ãã¯æ—¢ã«ç™»éŒ²æ¸ˆã¿ã§ã™ã€‚");
      }
    });

    document.getElementById("togetherPairForm").addEventListener("submit", e => {
      e.preventDefault();
      const n1 = document.getElementById("togetherName1").value;
      const n2 = document.getElementById("togetherName2").value;
      if (addPair("together", n1, n2)) {
        document.getElementById("togetherName1").value = "";
        document.getElementById("togetherName2").value = "";
      } else {
        alert("åå‰ãŒç©ºæ¬„ã‹åŒã˜ã€ã‚‚ã—ãã¯æ—¢ã«ç™»éŒ²æ¸ˆã¿ã§ã™ã€‚");
      }
    });
    
    document.getElementById("sort-reading").addEventListener("click", () => {
        currentSortMode = 'reading';
        updateSortButtons('sort-reading');
        renderPlayers();
    });

    document.getElementById("sort-recent").addEventListener("click", () => {
        currentSortMode = 'recent';
        updateSortButtons('sort-recent');
        renderPlayers();
    });

    document.getElementById("sort-count").addEventListener("click", () => {
        currentSortMode = 'count';
        updateSortButtons('sort-count');
        renderPlayers();
    });

    function updateSortButtons(activeId) {
        document.querySelectorAll('.sort-buttons button').forEach(btn => {
            btn.classList.remove('active');
        });
        document.getElementById(activeId).classList.add('active');
    }

    function resolveAliases(names) {
      return names.map(name => playerAliasMap[katakanaToHiragana(name).toLowerCase()] || name);
    }
    
    async function initializePage() {
      const readingsSnapshot = await db.ref("player_readings").once("value");
      readingsData = readingsSnapshot.val() || {};
      
      for (const name in readingsData) {
        if (readingsData[name].aliases) {
          readingsData[name].aliases.forEach(alias => {
            playerAliasMap[katakanaToHiragana(alias).toLowerCase()] = name;
          });
        }
      }

      db.ref("apex_results").on("value", (snapshot) => {
        if (snapshot.exists()) {
          const data = snapshot.val();
          matches = Object.keys(data).map(key => ({ ...data[key], matchId: parseInt(key, 10) }));
          playerScoresAverage = calculateScoresAverage(matches);
          playerScoresWinRate = calculateWinRate(matches);
          playerScoresKDRatio = calculateKDRatio(matches);
          document.getElementById("matchCount").textContent = `éå»${matches.length}è©¦åˆã®ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒã‚’ã‚‚ã¨ã«ç”Ÿæˆã€‚`;
        }
        
        const allPlayersInMatches = new Set();
        matches.forEach(match => {
          (match.teamA || []).forEach(p => allPlayersInMatches.add(p));
          (match.teamB || []).forEach(p => allPlayersInMatches.add(p));
        });
        allPlayersList = Array.from(allPlayersInMatches);
        const sortedByReading = sortPlayers(allPlayersList, readingsData, 'reading');
        allPlayersList = sortedByReading;
        
        playerPlayDates = {};
        playerPlayCounts = {};
        matches.forEach(match => {
          const allPlayersInMatch = (match.teamA || []).concat(match.teamB || []);
          allPlayersInMatch.forEach(p => {
            playerPlayCounts[p] = (playerPlayCounts[p] || 0) + 1;
            playerPlayDates[p] = Math.max(playerPlayDates[p] || 0, match.matchNumber || 0);
          });
        });

        renderPlayers();
        makeTeams(); 
      });

      renderPairList("separate");
      renderPairList("together");
      
      db.ref("currentInputPlayers").on("value", (snapshot) => {
          const data = snapshot.val() || {};
          const now = Date.now();
          const playersToKeep = {};
          const playerKeysToRemove = [];

          for (const deviceId in data) {
              const deviceData = data[deviceId];
              if (deviceData.timestamp && (now - deviceData.timestamp) < 7200000) {
                  if (Array.isArray(deviceData.players)) {
                      playersToKeep[deviceId] = deviceData.players;
                  }
              } else {
                  playerKeysToRemove.push(deviceId);
              }
          }

          if (playerKeysToRemove.length > 0) {
              playerKeysToRemove.forEach(key => {
                  db.ref("currentInputPlayers").child(key).remove();
              });
          }
          
          firebaseMatchingPlayers = [];
          Object.values(playersToKeep).forEach(nameList => {
              if (Array.isArray(nameList)) {
                  nameList.forEach(name => {
                      if (name && name.trim() !== '') {
                          firebaseMatchingPlayers.push(name.trim());
                      }
                  });
              }
          });

          updateMatchingPlayers(); 
      });
    }

    document.querySelectorAll('input[name="method"]').forEach(radio => {
      radio.addEventListener("change", () => {
        makeTeams();
      });
    });

    // â˜…å‰Šé™¤: common.js ã«ç§»è­²ã•ã‚ŒãŸãƒ˜ãƒƒãƒ€ãƒ¼/ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã¯å‰Šé™¤ã—ã¾ã™ã€‚
    // const hamburger = document.getElementById("hamburger");
    // const nav = document.getElementById("nav");
    // hamburger.addEventListener("click", ... );
  </script>
</body>
</html>
